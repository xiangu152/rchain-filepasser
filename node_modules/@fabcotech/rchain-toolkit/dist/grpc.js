"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGrpcProposeClient = exports.getClient = exports.propose = exports.previewPrivateNames = exports.doDeploy = exports.lastFinalizedBlock = exports.getBlocks = exports.getBlock = exports.getMethod = void 0;
const getMethod = (options, client, method) => {
    return new Promise((resolve, reject) => {
        client[method](options, (err, resp) => __awaiter(void 0, void 0, void 0, function* () {
            if (err) {
                reject(err);
            }
            else {
                resolve(resp);
            }
        }));
    });
};
exports.getMethod = getMethod;
// Get block
const getBlock = (options, client) => {
    return (0, exports.getMethod)(options, client, "getBlock");
};
exports.getBlock = getBlock;
// Get blocks
const getBlocks = (options, client) => {
    return (0, exports.getMethod)(options, client, "getBlocks");
};
exports.getBlocks = getBlocks;
// Get blocks
const lastFinalizedBlock = (client) => {
    return (0, exports.getMethod)(undefined, client, "lastFinalizedBlock");
};
exports.lastFinalizedBlock = lastFinalizedBlock;
const doDeploy = (options, client) => {
    return (0, exports.getMethod)(options, client, "doDeploy");
};
exports.doDeploy = doDeploy;
// Preview private names
const previewPrivateNames = (options, client) => {
    return (0, exports.getMethod)(options, client, "previewPrivateNames");
};
exports.previewPrivateNames = previewPrivateNames;
// Propose
const propose = (options, client) => {
    return (0, exports.getMethod)(options, client, "propose");
};
exports.propose = propose;
const getClient = (grpcEndPoint, grpc, protoLoader, protoService) => {
    let path = "/protobuf/DeployServiceV1.proto";
    if (protoService === "proposeService") {
        path = "/protobuf/ProposeServiceV1.proto";
    }
    return new Promise((resolve, reject) => {
        protoLoader
            .load(__dirname + path, {
            keepCase: true,
            longs: String,
            enums: String,
            defaults: true,
            oneofs: true,
        })
            .then((packageDefinition) => {
            const packageObject = grpc.loadPackageDefinition(packageDefinition);
            let client;
            if (protoService === "deployService") {
                client = new packageObject.casper.v1.DeployService(grpcEndPoint, grpc.credentials.createInsecure());
            }
            else {
                client = new packageObject.casper.v1.ProposeService(grpcEndPoint, grpc.credentials.createInsecure());
            }
            resolve(client);
        })
            .catch((err) => {
            reject(err);
        });
    });
};
exports.getClient = getClient;
const getGrpcProposeClient = (grpcEndPoint, grpc, protoLoader) => {
    return (0, exports.getClient)(grpcEndPoint, grpc, protoLoader, "proposeService");
};
exports.getGrpcProposeClient = getGrpcProposeClient;
//# sourceMappingURL=grpc.js.map